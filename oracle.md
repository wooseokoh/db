- SQL 처리 과정

```
Parser(SQL Parsing)
- 문법체크, 정당성 체크 , 라이브러리 캐시에서 동일문장 찾기

Optimizer(Optimization)
- Query Transformer : 적절한 문장으로 변환하기 (meerge, inline view 풀기 등등)
- Estimator : 비용계산 (모든 경우의 수 계산, 테이블수 조인방법에 따라 상당한 cpu 자원 소모가 동반됨)
- Plan Generator : 비용이 적게 드는 plan 결정

Row-Source Generator(Row-Source Generation)
- 오라클만 해석가능한 기계어로 전환하기

SQL Engine(Excution)

소프트파싱 vs 하드파싱

소프트파싱 : Shared Pool에 존재하는 SQL 실행계획을 공유하여 최적화 과정 생략 SQL 실행
SQL Parsing -> Excution : 공유된 실행계획 재사용시 소프트파싱

하드파싱 : SQL이 캐싱되어 있지 않을때 최적화 과정을 통해 실행계획 생성, Row-Source 생성하는 과정을 수행
Optimization && Row-Source Generation : 저장된 SQL 실행계획이 없어서 신규SQL로 인지되면 하드파싱

* 하드 파싱 비율이 적으면 문제 발생이 없지만 요청되는 SQL이 계속 하드파싱이 일어나면 CPU자원을 계속 요청하게 되면 이와 함께 SAG의 라이브러리 캐시에 이미 저정되어있는 SQL을 신규 SQL이 계속 밀어내서 결과적으로 모든 SQL이 계속 하드 파싱이 일어나서 CPU FULL..

```

- 인덱스

```
full scan
1. SQL문에 조건이 존재하지 않는경우
2. SQL문의 주어진 조건에 사용 가능한 인덱스가 없는경우
3. 옵티마이저의 선택
4. 병렬처리 방식일때 또는 힌트사용

인덱스 VS FULL SCAN
- SQL에 따라 인덱스를 타느것보다 FULL SCAN이 빠른 경우가 있다.
- 인덱스를 이용시에는 RowId를 이용한 싱글블록io이며 full scan시에는 db_file_multi_block_read_count 파라메터 값만큼의 멀티블록io가 일어난다
- 10 ~ 15% 이상부터는 full scan이 유리하다. : case by case

JOIN

Nest Loop Join
- Nested Loop Join은 가장 기본적인 조인 알고리즘 중 하나로, 두 개의 테이블을 조인하기 위해 중첩된 반복을 사용
- 대표적인 random acess
- index scan이라해도 대량의 데이터 조인시에는 나쁜 plan
- 부분범위처리
- 먼저 엑세스 되는 테이블의 처리 범위에 따라 전체 일량이 결정됨
- 소량의 데이터 처리나 부분점위 처리에 적합

1. 외부 테이블(드라이빙 테이블)을 선택합니다.
- 외부 테이블은 조인의 기준이 되는 테이블입니다.
- 보통은 작은 크기의 테이블을 외부 테이블로 선택합니다.

2. 외부 테이블의 첫 번째 행을 가져옵니다.

3. 내부 테이블(조인할 테이블)을 순차적으로 스캔하면서 외부 테이블의 각 행과 조인 조건을 비교합니다.
- 내부 테이블은 외부 테이블의 각 행과 비교할 테이블입니다.
- 조인 조건에 맞는 결과가 발견되면 결과에 추가합니다.

4. 내부 테이블의 모든 행을 스캔한 후, 다음 외부 테이블의 행을 가져와서 다시 내부 테이블을 스캔하며 조인을 수행합니다.
- 이 과정을 외부 테이블의 모든 행에 대해 반복합니다.

Sort Merge Join
- 조인시 inner, outer table의 인덱스가 둘다 없을떄..
- 인덱스 -> 테이블 -> sort merge가 일어나면서 추출버퍼에 담김
- 대량집합 조인이란 테이블자체가 크다가 아니라 조인해야할 양이 많다라는 것을 의미

1. 각 테이블을 조인 키를 기준으로 정렬합니다. 이를 위해 정렬 작업을 수행해야 하므로 메모리나 임시 테이블을 사용할 수 있습니다.

2. 정렬된 테이블을 병합하면서 조인을 수행합니다. 정렬된 테이블은 조인 키의 순서로 병합되므로, 일치하는 조인 키 값을 가진 행들을 찾아서 조인합니다.

3. 정렬된 테이블을 순차적으로 스캔하면서 조인 키 값을 비교하고 조인을 수행합니다. 각 테이블에서 동일한 조인 키 값을 가진 행들을 조인하여 결과를 생성합니다.

Sort join에서는 일반적으로 작은 테이블을 선행으로 정렬하는 것이 성능상 이점을 가질 수 있습니다. 이는 작은 테이블을 정렬하고 조인 키를 기준으로 큰 테이블을 스캔하는 방식으로 동작하기 때문입니다. 

정렬 비용 최소화: 작은 테이블을 선행으로 정렬하면 정렬 작업에 소요되는 비용이 줄어듭니다. 작은 테이블의 정렬은 메모리나 임시 테이블에 적은 양의 데이터만 필요로 하기 때문에 비교적 빠르게 수행될 수 있습니다.

메모리 효율성: 작은 테이블을 선행으로 정렬하면 정렬된 작은 테이블을 메모리에 올려놓을 수 있습니다. 이렇게 하면 큰 테이블을 스캔하면서 작은 테이블을 메모리에서 조인할 수 있어 메모리 효율성이 높아집니다.

I/O 비용 감소: 작은 테이블을 선행으로 정렬하면 정렬된 작은 테이블을 이후에 스캔하면서 조인할 수 있으므로 I/O 비용을 줄일 수 있습니다. 정렬된 테이블을 스캔하면서 조인할 때 필요한 I/O 작업은 정렬되지 않은 테이블을 스캔하면서 필요한 I/O 작업보다 적을 수 있습니다.

Hash Join

1. Build 단계 (Hash Table 생성)
- Inner(작은) 테이블의 데이터를 읽어와서 해시 함수를 사용하여 해시 테이블을 생성합니다.
- 해시 함수는 테이블의 조인 컬럼 값을 기반으로 해시 버킷을 결정합니다.
- Inner 테이블의 각 행은 해당하는 해시 버킷에 저장됩니다.
- 동일한 해시 버킷에 여러 개의 행이 저장될 수 있으므로, 이를 처리하기 위해 체이닝 또는 개방 주소법과 같은 충돌 해결 방법이 사용될 수 있습니다.

2. Probe 단계 (Hash Table 조회)
- Outer(큰) 테이블의 데이터를 읽어와서 해시 함수를 사용하여 각 행을 해시 버킷에 매핑합니다.
- 매핑된 해시 버킷에서 Inner 테이블과의 조인을 수행합니다.
- 만약 체이닝 또는 개방 주소법을 사용하여 충돌이 발생한 경우, 해당 버킷에서 선형 검색이 수행될 수 있습니다.
- 일치하는 조인 행이 발견되면 결과를 반환합니다.

3.조인 결과 생성
- Probe 단계에서 일치하는 조인 행이 발견되면, 해당 조인 행을 결과로 반환합니다.
- 모든 Outer 테이블의 행에 대해 Probe 단계를 반복하여 조인 결과를 완성합니다.
- 최종적으로 모든 조인 결과가 생성되면, 이를 쿼리의 결과로 반환합니다.
```

- 인덱스 스캔

```
- 컬럼의 값의 기반으로 인덱스를 검색하여 데이터를 추출하는 엑세스 기법.
- 인덱스 데이터가 저장된 레코드의 블럭 주소를 획득한뒤 테이블데이터 블록을 i/o하여 데이터를 버퍼에 싣는다.

1. SQL문이 필요로 하는 모든 컬럼이 인덱스 구성 컬럼에 포함되어 있다면 테이블 엑세스 불필요
: 불필요 SELECT 컬럼을 뺴야되는 이유.

2. 구성컬럼의 순서로 SORT되어 있으므로 인덱스사용한 데이터 검색결과는 인덱스 데이터순으로 정렬되면서 버퍼에 담긴다.
: 불필요한 ORDER BY를 남발하지 않아야 하는 이유

3. 인덱스 스캔은 블록주소를 이용해서 검색하며 기본적으로 한번의 io요청에 한블록씩 데이터를 읽는다.
: single block i/o는 소량조회시 유리하고 많은 양의 인덱스 스캔은 오히려 독이 되는 이유

디스크 I/O 비용
- 디스크 I/O는 데이터베이스 성능에 있어서 주요한 병목 현상 중 하나입니다. 
- 디스크에서 데이터를 읽는 비용은 상대적으로 높기 때문에, 많은 양의 인덱스 블록을 읽어야 할 경우 I/O 비용이 크게 증가합니다.

캐시 활용의 제한
- 디스크 I/O를 최소화하기 위해 데이터베이스 엔진은 버퍼 캐시를 사용하여 데이터를 메모리에 유지합니다. 
- 하지만 한 번의 I/O 요청에 한 블록씩 데이터를 읽는 경우, 큰 인덱스를 스캔하면서 캐시의 공간 한계로 인해 계속해서 디스크 I/O가 발생할 수 있습니다. 
- 이로 인해 캐시의 효율성이 저하되고 전체적인 성능이 저하될 수 있습니다.

순차적 I/O vs 랜덤 I/O
- 한 번의 I/O 요청에 한 블록씩 데이터를 읽는 인덱스 스캔은 순차적인 I/O 패턴입니다. 
- 그러나 많은 양의 인덱스를 스캔하는 경우, 랜덤 I/O 패턴으로 인해 디스크의 헤드 이동이 잦아질 수 있습니다. 
- 이로 인해 디스크 I/O의 지연이 증가하고 전체적인 성능이 저하될 수 있습니다.

많은 양의 인덱스를 스캔해야 하는 경우에는 한 번의 I/O 요청에 많은 양의 데이터를 읽을 수 있는 방법이 더 효율적입니다. 

이를 위해 다양한 기법들이 사용되는데, 예를 들어 다중 블록 I/O 또는 인덱스 키의 범위를 활용하여 더 큰 범위의 데이터를 한 번에 읽어오는 등의 방법이 있습니다.

이러한 기법들은 디스크 I/O를 최소화하고 메모리 및 캐시 활용을 최적화하여 인덱스 스캔 성능을 향상시킵니다.
```

- 실행계획

```
실행계획의 필요성
- 작성자의 의도에 맞게 동작하는지 확인
: 통계정보와 실데이터의 불일치에 따른 잘모된 플랜을 미리 예방하기 위해서는 간단한 쿼리라도 플랜을 확인해줘야함.

- 일반적으로 서브쿼리가 있는 SQL에서 옵티마이저의 잘못된 판단으로 비효율적 수행경로 문제가 많음
1) 서브쿼리가 메인쿼리만큼 FULL SCAN
2) 인라인뷰가 머저 실행되어 집합의 크기가 작아지는데도 불구하고 STATIC 쿼리의 한계로 인해 잘못된 판단으로 인라인뷰를 후행으로 선택
3) 집합이 작다고 판단해서 뷰 MERGE를 하여 NL JOIN으로 무한정 풀고 있는 상황

```

서브쿼리
```sql
단일 행 서브쿼리(Single-Row Subquery): 서브쿼리의 결과가 단일 행을 반환하는 경우 사용됩니다. 예를 들어, 다음은 주문 테이블에서 가장 비싼 제품의 가격을 조회하는 단일 행 서브쿼리의 예입니다.

SELECT order_id, product_name, price
FROM orders
WHERE price = (SELECT MAX(price) FROM products);

다중 행 서브쿼리(Multiple-Row Subquery): 서브쿼리의 결과가 여러 행을 반환하는 경우 사용됩니다. 예를 들어, 다음은 부서별로 평균 급여보다 많은 사원들을 조회하는 다중 행 서브쿼리의 예입니다.

SELECT employee_id, employee_name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees GROUP BY department_id);

다중 열 서브쿼리(Multiple-Column Subquery): 서브쿼리의 결과가 여러 열을 반환하는 경우 사용됩니다. 예를 들어, 다음은 주문 테이블에서 각 제품의 주문 수량과 재고 수량을 비교하는 다중 열 서브쿼리의 예입니다.

SELECT product_name, order_quantity, stock_quantity
FROM products
WHERE (order_quantity, stock_quantity) IN (SELECT order_quantity, stock_quantity FROM orders);

스칼라 쿼리 (Scalar Query):

스칼라 쿼리는 단일 값(스칼라 값)을 반환하는 쿼리입니다.
스칼라 값은 하나의 행과 하나의 열로 구성됩니다.
주로 SELECT 절, WHERE 절, HAVING 절, SET 절에서 사용됩니다.
예를 들어, 다음은 products 테이블에서 가장 비싼 제품의 가격을 조회하는 스칼라 쿼리입니다:

SELECT MAX(price) FROM products;

인라인 뷰 (Inline View):

인라인 뷰는 서브쿼리를 사용하여 쿼리 내에서 가상의 테이블을 생성하는 방법입니다.
서브쿼리의 결과를 일시적인 테이블로 취급하며, 이를 주 쿼리에서 참조할 수 있습니다.
인라인 뷰는 주로 FROM 절에서 사용됩니다.
예를 들어, 다음은 employees 테이블에서 급여가 평균 이상인 사원들을 조회하는 인라인 뷰를 사용하는 예입니다:

SELECT employee_id, employee_name, salary
FROM (SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees)) AS inline_view;

서브쿼리 (Subquery):

서브쿼리는 다른 쿼리 내에 포함된 쿼리입니다.
서브쿼리는 주 쿼리의 일부로 사용되며, 서브쿼리의 결과는 주로 WHERE 절에서 사용됩니다.
서브쿼리는 단일 행, 다중 행, 다중 열에 따라 단일 행 서브쿼리, 다중 행 서브쿼리, 다중 열 서브쿼리로 구분됩니다.
서브쿼리는 SELECT 문, FROM 절, WHERE 절, HAVING 절, INSERT, UPDATE, DELETE 문 등 다양한 부분에서 사용될 수 있습니다.
예를 들어, 다음은 주문 테이블에서 가장 비싼 제품을 주문한 고객을 조회하는 서브쿼리를 사용하는 예입니다:

SELECT customer_id, customer_name
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders WHERE price = (SELECT MAX(price) FROM products));

상관 서브쿼리 (Correlated Subquery):

상관 서브쿼리는 외부 쿼리와 서브쿼리 간에 관계가 있는 서브쿼리입니다.
서브쿼리가 외부 쿼리의 컬럼을 참조하여 실행됩니다.
상관 서브쿼리는 주로 외부 쿼리의 각 행에 대해 서브쿼리를 반복적으로 실행하는 경우 사용됩니다.

EXISTS 서브쿼리 (EXISTS Subquery)

EXISTS 서브쿼리는 서브쿼리의 결과가 존재하는지 여부를 확인하기 위해 사용됩니다.
외부 쿼리의 조건에 따라 EXISTS 서브쿼리가 참이면 외부 쿼리 결과에 해당 행이 포함됩니다.
주로 WHERE 절에서 사용되며, 서브쿼리의 결과는 중요하지 않고 존재 여부만 확인하는 용도로 사용됩니다.

IN 서브쿼리 (IN Subquery)

IN 서브쿼리는 외부 쿼리의 조건과 일치하는 값을 가진 서브쿼리 결과를 반환합니다.
서브쿼리의 결과를 외부 쿼리의 조건에 대해 비교하여 참인 경우 외부 쿼리 결과에 해당 행이 포함됩니다.
주로 WHERE 절에서 사용되며, 서브쿼리의 결과가 여러 값이거나 다른 쿼리일 수도 있습니다.
서브쿼리는 복잡한 쿼리 작성을 가능하게 해주는 강력한 도구입니다. 그러나 서브쿼리의 성능을 고려하여 최적화하는 것이 중요하며, 적절한 인덱스를 사용하거나 조인을 활용하여 성능을 향상시킬 수 있습니다.

```
