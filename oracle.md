- SQL 처리 과정

```
Parser(SQL Parsing)
- 문법체크, 정당성 체크 , 라이브러리 캐시에서 동일문장 찾기

Optimizer(Optimization)
- Query Transformer : 적절한 문장으로 변환하기 (meerge, inline view 풀기 등등)
- Estimator : 비용계산 (모든 경우의 수 계산, 테이블수 조인방법에 따라 상당한 cpu 자원 소모가 동반됨)
- Plan Generator : 비용이 적게 드는 plan 결정

Row-Source Generator(Row-Source Generation)
- 오라클만 해석가능한 기계어로 전환하기

SQL Engine(Excution)

소프트파싱 vs 하드파싱

소프트파싱 : Shared Pool에 존재하는 SQL 실행계획을 공유하여 최적화 과정 생략 SQL 실행
SQL Parsing -> Excution : 공유된 실행계획 재사용시 소프트파싱

하드파싱 : SQL이 캐싱되어 있지 않을때 최적화 과정을 통해 실행계획 생성, Row-Source 생성하는 과정을 수행
Optimization && Row-Source Generation : 저장된 SQL 실행계획이 없어서 신규SQL로 인지되면 하드파싱

```


- 인덱스 스캔

```
- 컬럼의 값으 기반으로 인덱스를 검색하여 데이터를 추출하는 엑세스 기법.
- 인덱스 데이터가 저장된 레코드의 블럭 주소를 획득한뒤 테이블데이터 블록을 i/o하여 데이터를 버퍼에 싣는다.

1. SQL문이 필요로 하는 모든 컬럼이 인덱스 구성 컬럼에 포함되어 있다면 테이블 엑세스 불필요
: 불필요 SELECT 컬럼을 뺴야되는 이유.

2. 구성컬럼의 순서로 SORT되어 있으므로 인덱스사용한 데이터 검색결과는 인덱스 데이터순으로 정렬되면서 버퍼에 담긴다.
: 불필요한 ORDER BY를 나발하지 않아야 하는 이유

3. 인덱스 스캔은 블록주소를 이용해서 검색하며 기본적으로 한번의 io요청에 한블록씩 데이터를 읽는다.
: single block i/o는 소량조회시 유리하고 맣ㄴ은 양의 인덱스 스캔은 오히려 독이 되는 이유

디스크 I/O 비용
- 디스크 I/O는 데이터베이스 성능에 있어서 주요한 병목 현상 중 하나입니다. 
- 디스크에서 데이터를 읽는 비용은 상대적으로 높기 때문에, 많은 양의 인덱스 블록을 읽어야 할 경우 I/O 비용이 크게 증가합니다.

캐시 활용의 제한
- 디스크 I/O를 최소화하기 위해 데이터베이스 엔진은 버퍼 캐시를 사용하여 데이터를 메모리에 유지합니다. 
- 하지만 한 번의 I/O 요청에 한 블록씩 데이터를 읽는 경우, 큰 인덱스를 스캔하면서 캐시의 공간 한계로 인해 계속해서 디스크 I/O가 발생할 수 있습니다. 
- 이로 인해 캐시의 효율성이 저하되고 전체적인 성능이 저하될 수 있습니다.

순차적 I/O vs 랜덤 I/O
- 한 번의 I/O 요청에 한 블록씩 데이터를 읽는 인덱스 스캔은 순차적인 I/O 패턴입니다. 
- 그러나 많은 양의 인덱스를 스캔하는 경우, 랜덤 I/O 패턴으로 인해 디스크의 헤드 이동이 잦아질 수 있습니다. 
- 이로 인해 디스크 I/O의 지연이 증가하고 전체적인 성능이 저하될 수 있습니다.

많은 양의 인덱스를 스캔해야 하는 경우에는 한 번의 I/O 요청에 많은 양의 데이터를 읽을 수 있는 방법이 더 효율적입니다. 

이를 위해 다양한 기법들이 사용되는데, 예를 들어 다중 블록 I/O 또는 인덱스 키의 범위를 활용하여 더 큰 범위의 데이터를 한 번에 읽어오는 등의 방법이 있습니다.

이러한 기법들은 디스크 I/O를 최소화하고 메모리 및 캐시 활용을 최적화하여 인덱스 스캔 성능을 향상시킵니다.
```
